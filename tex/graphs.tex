% Graph

\begin{itemize}
    \item \textbf{Node/ Vertex:} Object with name and data (in context of molecules: the atoms)
    \item \textbf{Edge:} Connection between two vertices (in context of molecules: the bond)
    \begin{itemize}
        \item Can be weighted (in context of molecules: single bond and double bond)
        \item Can be directed 
    \end{itemize}
    \item \textbf{Graph:} Collection of nodes and edges
    \begin{center}\includegraphics[width=0.85\textwidth]{img/graphs/DifferentGraphs.png}\end{center}
    \item \textbf{Valence of degree of vertex:} Number of edges a vertex lies on (in context of molecules: valence)
    \item \textbf{Adjacent vertices:} Vertices connected by an edge (in context of molecules: neibouring atoms)
    \item \textbf{Path:} List of distinct vertices in which successive vertices are connected by edges
    \begin{itemize}
        \item Simple Path: path with no vertex occurring twice
        \item Cycle Path: simple path of which first and last vertex are the same
    \end{itemize}
    \begin{center}\includegraphics[width=0.85\textwidth]{img/graphs/PathGraphs.png}\end{center}
    \item \textbf{Trees:} (in graph theory)
    \begin{itemize}
        \item \textbf{Tree:} non-empty, acyclic collection of nodes and edges (graph) in which any 2 nodes are connecteds by exactly 1 path.  
        \item \textbf{Ordered Tree:} tree with order in the children nodes
        \item \textbf{Binary Tree:} ordered tree in which each non-terminal node has exactly two children
        \item \textbf{Binary Search Tree:} ordered binary tree with left-to-right order
        \item \textbf{Heap:} ordered binary tree with top-to-bottom order
    \end{itemize}
    \begin{center}\includegraphics[width=0.85\textwidth]{img/graphs/GraphsTrees.png}\end{center}
\end{itemize}

\subsection{Representations of graphs}

A graph $G(V,E)$ with vertices $V$ and edges $E$ can be represented as a adjacency matrix (good for dense graphs) or an adjacency list (good for sparse graphs). 

\begin{center}\includegraphics[width=0.85\textwidth]{img/graphs/MatrixVsList.png}\end{center}

\begin{table}[H]
    \centering
    \begin{tabular}{p{30mm} | p{50mm} | p{50mm}}
        \toprule
        \textbf{Function} & \textbf{Adjacency list} & \textbf{Adjacency matrix} \\
        \midrule
        \lstinline|size()| & Easy, size of a vector & Easy, soize of a vector \\
        \midrule
        \lstinline|isConnected()| & Difficult, search in linked list & Easy, direct access \\
        \midrule
        \lstinline|getNeighbours()| & Easy, copy of linked list & Difficult, search in row \\
        \midrule
        \lstinline|addEdge()| & Easy, append linked list & Easy, set matrix element to 1 \\
        \bottomrule
    \end{tabular}
\end{table}

\subsubsection{Adjacency list}

\lstinputlisting[language=C++]{src/graphs/graph_list.cpp}

\subsubsection{Adjacecy matrix}

\lstinputlisting[language=C++]{src/graphs/graph_matrix.cpp}

\subsection{Searching a graph}

When searching for a vertex in a graph, two different algorithms can be used: the first depth-first, the second breadth-first.

\subsubsection{Breadth-first (BF) search}

The breadth-first algorithm starts with a specific source vertex $s$, from which all vertices that can be reached from $s$ are discovered. This creates a breadth-first tree with the root $s$ and all reachable vertices.  During the algorithm, the shortest path (distance) from $s$ to $v$ is also determined for each vertex $v$. The vertices have three possible states:

\begin{itemize}
    \item \textbf{white:} undiscovered
    \item \textbf{gray:} discovered but with undiscovered neighbours
    \item \textbf{black:} discovered and all neighbours are discovered as well
\end{itemize}

All gray vertices are in a queue so that they can be processed one after the other. The running time of the algorithm is $\Theta(V+E)$.

Procedure:
\begin{enumerate}
    \item First, only the given root $s$ is gray.
    \item All neighboring vertices of $s$ become gray, their distance is 1 and $s$ becomes black.
    \item All neighbors of the gray vertices become gray, their distance is 2 and the former gray vertices become black. The gray vertices in the queue are processed one after the other.
\end{enumerate}

\begin{center}\includegraphics[width=0.85\textwidth]{img/graphs/BfSearch.png}\end{center}

% finished code, but without outpur of the searching
\lstinputlisting[language=C++]{src/graphs/bf_search.cpp}

\subsubsection{Depth-first (DF) search}

If possible, the depth-first algorithm always searches deeper in the tree first and not as broadly as possible as with the BF algorithm. This creates a depth-first forest. Here, too, you start with a source vertex $s$ and discover all vertices that can be reached via $s$, but the three classifications of the vertices are slightly different:

\begin{itemize}
    \item \textbf{white:} undiscovered
    \item \textbf{gray:} first discovered (time $d$)
    \item \textbf{black:} all neighbours are discovered (time $f$)
\end{itemize}

The running time of the algorithm is $\Theta(V+E)$. If vertices remain after the algorithm that cannot be reached from the source $s$, the algorithm is continued via a new source $s$.

Procedure:
\begin{enumerate}
    \item First, only the given root $s$ is gray. (0)
    \item Then the neighbor of $s$ becomes gray with the smallest value. (1)
    \item Then the neighbor of (1) with the smallest value is grayed out again. (2) This continues until a vertex is found that has no neighbors. (3)
    \item Now the backtracking begins until a vertex is found that still has unexplored neighbors. This then turn gray and the procedure continues.
\end{enumerate}

% finished code, but without outpur of the searching
\lstinputlisting[language=C++]{src/graphs/df_search.cpp}

\subsection{Minimum spanning trees}

The \emph{minimum spanning trees problem} is to turn a graph into a tree such that all vertices are connected and the sum of the edge weights is minimal. An important property of this tree is that if the vertices of the graph are arbitrarily divided into two sets, the minimum spanning tree always contains the shortest path between two vertices from both sets. In principle, two algorithms can be applied to the problem, namely \emph{Kruskal's algorithm} (good for sparse graphs) and \emph{Prim's algorithm} (good for dense graphs), which both run in $\Theta(E\lg V)$ time for a graph $G(V,E)$ with vertices $V$ and edges $E$.

\begin{center}\includegraphics[width=0.85\textwidth]{img/graphs/MinimumSpanningTree.png}\end{center}

\subsubsection{Kruskal's algorithm}

In Kruskal's algorithm, the minimum spanning tree is constructed by joining a set of unconnected vertices together. The tree is therefore built from the root and no edges are deleted, which is why it is particularly suitable for sparse graphs.

Procedure:
\begin{enumerate}
    \item Put the edge with the lowest weight in a tree of the forest
    \item Put the edge into the forest with the next higher weight (algorithm follows ascending weights), provided that adding it does not create a cycle. If it does, skip that edge.
    \item Stop after $V-1$ edges have been considered (ensures that all vertices are connected to each other). 
\end{enumerate}

\begin{center}\includegraphics[width=0.85\textwidth]{img/graphs/KruskalGraph.png}\end{center}

\lstinputlisting[language=C++]{src/graphs/kruskal.cpp}

\subsubsection{Prim's algorithm}


\begin{center}\includegraphics[width=0.85\textwidth]{img/graphs/PrimGraph.png}\end{center}

\lstinputlisting[language=C++]{src/graphs/prim.cpp}

\subsection{Single-source shortest paths}

\subsubsection{Brute-force}

\subsubsection{Dijkstra's algorithm}

\subsection{All-pair shortest paths}

\subsubsection{Floyd-Warshall algorithm}