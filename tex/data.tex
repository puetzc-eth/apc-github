% Data structures (week 2-3)

\deff{Data Type}{A data type is a classification for one of several types of data. A distinction is made between primitive data types (int double, float, bool, char) and advanced data types such as classes or heaps.}

\begin{itemize}
    \item \textbf{Composite data types:} contain multiple primitive data types
    \item \textbf{Classes:} contain primitive data types and functions
    \item \textbf{Abstract data types:} type that does not specify an implementation
\end{itemize}

\deff{Data Structure}{A data structure is a combination of several identical or different data types.}

\subsection{Composite Data Types}

\subsubsection{Structures}

\deff{Structures}{Structures is a data type whose variables and functions are always public. Normally structs are only used for data storage, as otherwise classes are used whose members are private by default.}

Since the members of a structs are public, the members of a structs can also be accessed without getter or setter functions (with a dot between struct name and variable name).

\lstinputlisting[language=C++]{src/data/struct.cpp}

\subsubsection{Unions}

\deff{Unions}{Similar to a struct, a union can also have several members declared, but can only store one member. If the first variable is used first and then the second, the first is overwritten.}

\lstinputlisting[language=C++]{src/data/union.cpp}

Unions are no longer used in modern C++ because, as can be seen above, it is not an error to ask for the previous data type of a union, only the values of the new data type are returned, which does not make unions \emph{type safe}. For this reason, the variant type (std::variant<struct rectangle, struct circle> vshape) was introduced with C++17, which is type safe and outputs an error as soon as an overwritten data type is requested. 

\subsubsection{Enumerations}

\deff{Enumerations}{For enumerations, so-called tags (the tags Monday, Tuesday, ...) are interpreted as ascending ints, which can then be used in the main program. }

\lstinputlisting[language=C++]{src/data/enum.cpp}

Since ints can also be used for arithmetic operations, the tags can also be used for normal calculations, but there is also an enum class that cannot do this, as this can often be confusing.

\subsection{Classes}

\deff{Class}{Variables and functions are stored in a class, but by default all members of a class are initially private, although the access type (private, protected or public) can be defined individually for each member.}

\begin{itemize}
    \item \textbf{public:} variable/functions can be accessed by everone
    \item \textbf{protected:} access only for derived classes
    \item \textbf{private:} (default) only accessible within class
\end{itemize}

Classes can have certain member types:

\begin{itemize}
    \item \textbf{Constructor(s) and Destructor}
    \begin{itemize}
        \item Automatic initialization and deletion of a class instance
        \item One destructor but more than one constructor can be specified with different parameters (function overloading)
    \end{itemize}
    \item \textbf{Copy constructor}
    \begin{itemize}
        \item Special constructor to make an exact copy of a class instance.
    \end{itemize}
    \item \textbf{Assignment operator}
    \item \textbf{Scope resolution operator}
\end{itemize}

\lstinputlisting[language=C++]{src/data/class.cpp}

\subsection{Abstract Data Types}

\subsubsection{Stacks and queues}

\lstinputlisting[language=C++]{src/data/stack.cpp}

\lstinputlisting[language=C++]{src/data/queue.cpp}

\subsubsection{Linked lists}

\subsubsection{Trees (binary search tree)}

\subsubsection{Heaps}

\subsubsection{Hash tables}

\subsection{Contiguous implementation}

\subsection{Pointers}

\subsection{Dynamic implementation}

\subsection{Standard Template Library (STL)}

\subsection{Hash table example}