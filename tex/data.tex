% Data structures (week 2-3)

\deff{Data Type}{A data type is a classification for one of several types of data. A distinction is made between primitive data types (int double, float, bool, char) and advanced data types such as classes or heaps.}

\begin{itemize}
    \item \textbf{Composite data types:} contain multiple primitive data types
    \item \textbf{Classes:} contain primitive data types and functions
    \item \textbf{Abstract data types:} type that does not specify an implementation
\end{itemize}

\deff{Data Structure}{A data structure is a combination of several identical or different data types.}

\subsection{Composite Data Types}

\subsubsection{Structures}

\deff{Structures}{Structures is a data type whose variables and functions are always public. Normally structs are only used for data storage, as otherwise classes are used whose members are private by default.}

Since the members of a structs are public, the members of a structs can also be accessed without getter or setter functions (with a dot between struct name and variable name).

\lstinputlisting[language=C++]{src/data/struct.cpp}

\subsubsection{Unions}

\deff{Unions}{Similar to a struct, a union can also have several members declared, but can only store one member. If the first variable is used first and then the second, the first is overwritten.}

\lstinputlisting[language=C++]{src/data/union.cpp}

Unions are no longer used in modern C++ because, as can be seen above, it is not an error to ask for the previous data type of a union, only the values of the new data type are returned, which does not make unions \emph{type safe}. For this reason, the variant type (std::variant$<$struct rectangle, struct circle$>$ vshape) was introduced with C++17, which is type safe and outputs an error as soon as an overwritten data type is requested. 

\subsubsection{Enumerations}

\deff{Enumerations}{For enumerations, so-called tags (the tags Monday, Tuesday, ...) are interpreted as ascending ints, which can then be used in the main program. }

\lstinputlisting[language=C++]{src/data/enum.cpp}

Since ints can also be used for arithmetic operations, the tags can also be used for normal calculations, but there is also an enum class that cannot do this, as this can often be confusing.

\subsection{Classes}

\deff{Class}{Variables and functions are stored in a class, but by default all members of a class are initially private, although the access type (private, protected or public) can be defined individually for each member.}

\begin{itemize}
    \item \textbf{public:} variable/functions can be accessed by everone
    \item \textbf{protected:} access only for derived classes
    \item \textbf{private:} (default) only accessible within class
\end{itemize}

Classes can have certain member types:

\begin{itemize}
    \item \textbf{Constructor(s) and Destructor}
    \begin{itemize}
        \item Automatic initialization and deletion of a class instance
        \item One destructor but more than one constructor can be specified with different parameters (function overloading)
    \end{itemize}
    \item \textbf{Copy constructor}
    \begin{itemize}
        \item Special constructor to make an exact copy of a class instance.
    \end{itemize}
    \item \textbf{Assignment operator}
    \begin{itemize}
        \item reassign existing = operator to handle use for classes (ex operator=, for $\mathrm{class\_inst\_1 = class\_inst\_2}$)
        \item this doubles as a copy operator
    \end{itemize}
    \item \textbf{Scope resolution operator}
\end{itemize}

\lstinputlisting[language=C++]{src/data/class.cpp}

\subsection{Abstract Data Types}

\subsubsection{Stacks and queues}

\lstinputlisting[language=C++]{src/data/stack.cpp}

\lstinputlisting[language=C++]{src/data/queue.cpp}

\subsubsection{Linked lists}
\textit{A linked list is like a chain, where each segment holds the value of the segment, as well as the pointer to the next segment. The last element points to NULL, and the pointer to the first element must be passed along with the list. \\ 
When a new element with value \emph{v} and a pointer to its storage \emph{ptr\_to} is added, it is first assigned the pointer to the first position \emph{ptr\_from = ptr\_first}, then the pointer to the first is changed to the pointer to the new element \emph{ptr\_first = ptr\_to}. \\
This proceeds analogously, if the new element is inserted in the middle of the linked list.}

\subsubsection{Trees (binary search tree)}
\deff{Tree}{A structure of nodes, with each node having a certain amount of children, and only one parent. Nodes of the same level are not interconnected, and terminal nodes are coined leafs. Each node contains a value (and can additionally have a key (i.e. its priority), and one or more pointers to each of its children. Leafs only have a value and point to NULL.}
\deff{Binary Search Tree}{A tree, in which each node only has two children (thus only two edges from, and one edge to it). All nodes with lower key value are left of the node, all that have higher key value, are right of it.}

\subsubsection{Heaps}
\deff{Heaps}{A heap is a kind of binary tree, where in each parent nodes key value is larger than or equal to the key value of its children. This enforces a "top to bottom" order, unlike the "left to right" order of a binary ordered tree.}

\subsubsection{Hash tables}
\deff{}{}

\subsection{Contiguous implementation}

\subsection{Pointers}

\subsection{Dynamic implementation}

\subsection{Standard Template Library (STL)}

\subsection{Hash table example}